#include <stdio.h>
#include <string.h>

void good_function() {
    printf("This is the normal, safe function.\n");
}

void malicious_code() {
    printf("!!! YOU HAVE BEEN HACKED !!!\n");
    // In a real attack, this would be shellcode.
}

void vulnerable_call(char* input) {
    char buffer[32];
    
    // A function pointer on the stack,
    // pointing to the 'good_function'.
    void (*function_ptr)() = &good_function;

    // VULNERABILITY: A stack buffer overflow...
    strcpy(buffer, input);
    // ...if 'input' is long enough, it will overwrite 'buffer'
    // and then overwrite 'function_ptr' with the address
    // of 'malicious_code'.

    // The program *thinks* it is calling good_function...
    function_ptr();
    // ...but the attacker has changed it to call malicious_code.
}

int main() {
    // A carefully crafted string that contains 32 'A's
    // to fill the buffer, followed by the 8-byte
    // address of 'malicious_code'.
    // (This is a simplified example; calculating the
    // exact address is complex in a real program).
    
    // For this example, we'll just show the concept:
    printf("Address of malicious_code is %p\n", &malicious_code);
    char attack_string[64];
    memset(attack_string, 'A', 32); // Fill the buffer
    
    // This line conceptually copies the *address*
    // This is hard to demo simply, but the principle is:
    // [32 bytes of 'A'] + [Address of malicious_code]
    
    // We will just use a simple overflow to show the principle
    vulnerable_call("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
    
    return 0;
}
